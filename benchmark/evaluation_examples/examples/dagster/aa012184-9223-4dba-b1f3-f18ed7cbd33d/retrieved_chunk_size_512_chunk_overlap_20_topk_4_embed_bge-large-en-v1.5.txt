Documentation Source:
release-1-7-2.dagster.dagster-docs.io/guides/dagster/intro-to-ops-jobs/connecting-ops.txt

Documentation Title:
Intro to ops and jobs, part two: Connecting ops in jobs | Dagster Docs

Documentation Content:
Dagster models these dataflow dependencies with inputs and outputs.
In this part, you'll:
Expand the
serial
job from part one
to encompass multiple ops
Use the output of one op as the input to another op
Step 1: Expand the serial job
#
We'll expand the job we worked with in the first section of the tutorial into two ops that:
Get the sizes of all the files in our directory
Report the sum of the file sizes. In a more realistic setting, we'd send an email or Slack message. For simplicity, we just emit a log message.
This will allow us to re-run the code that reports the summed size without re-running the code that crawls the filesystem. If we spot a bug in our reporting code, or if we decide we want to change how we report it, we won't need to re-crawl the filesystem.
import
os
from
dagster
import
get_dagster_logger
,
job
,
op
@op
def
get_file_sizes
(
)
:
files
=
[
f
for
f
in
os
.
listdir
(
"."
)
if
os
.
path
.
isfile
(
f
)
]
return
{
f
:
os
.
path
.
getsize
(
f
)
for
f
in
files
}
@op
def
report_total_size
(
file_sizes
)
:
total_size
=
sum
(
file_sizes
.
values
(
)
)
# In real life, we'd send an email or Slack message instead of just logging:
get_dagster_logger
(
)
.
info
(
f"Total size:
{
total_size
}
"
)
@job
def
serial
(
)
:
report_total_size
(
get_file_sizes
(
)
)
You'll see that we've modified our existing
get_file_sizes
op to return an output, in this case a dictionary that maps file names to their sizes.
We've defined our new op,
report_total_size
, to take an input,
file_sizes
.
We can use inputs and outputs to connect ops to each other.



Documentation Source:
release-1-7-2.dagster.dagster-docs.io/guides/dagster/intro-to-ops-jobs/single-op-job.txt

Documentation Title:
Intro to ops and jobs, part one: Write a single-op job | Dagster Docs

Documentation Content:
path
.
getsize
(
f
)
}
"
)
In this simple case, our op takes no arguments, and also returns no outputs. Don't worry, we'll soon encounter ops that are more dynamic.
Step 2: Write your first job
#
To execute our op, we'll embed it in an equally simple job. A job is a set of ops arranged into a
DAG
of computation. You'll typically define jobs by annotating ordinary Python functions with the
@job
decorator.
@job
def
file_sizes_job
(
)
:
get_file_sizes
(
)
Here you'll see that we call
get_file_sizes()
. This call doesn't actually execute the op. Within the bodies of functions decorated with
@job
, we use function calls to indicate the dependency structure of the op making up the job. Here, we indicate that the execution of
get_file_sizes
doesn't depend on any other ops by calling it with no arguments.
Step 3: Execute your first job
#
Assuming you’ve saved this job as
hello.py
, you can execute it via any of three different mechanisms:
Dagster UI
Dagster CLI
Python API
Dagster UI
#
To visualize your job (which only has one op) in the UI, just run the following. Make sure you're in the directory in which you've saved the job file:
dagster dev -f hello.py
You'll see output like:
Serving dagster-webserver on http://127.0.0.1:3000
in
process
70635
You should be able to navigate to
http://127.0.0.1:3000
in your web browser and view your job. It isn't very interesting yet, because it only has one op.
Click on the
Launchpad
tab and you'll see the view below.
The large upper left pane is empty here, but, in jobs with parameters, this is where you'll be able to edit job configuration on the fly.
Click the
Launch Run
button on the bottom right to execute this job directly from the UI.



Documentation Source:
release-1-7-2.dagster.dagster-docs.io/guides/dagster/intro-to-ops-jobs/single-op-job.txt

Documentation Title:
Intro to ops and jobs, part one: Write a single-op job | Dagster Docs

Documentation Content:
Intro to ops and jobs, part one: Write a single-op job | Dagster Docs
Ask AI
Platform
Dagster+
New
Pricing
Blog
Community
Docs
Sign in
Join us on Slack
Star us
Try Dagster+
Platform
Dagster+
Pricing
Blog
Community
Docs
Contact Sales
Sign in
Try Dagster+
Search
the docs
Press
Ctrl
and
K
to search
Getting started
What's Dagster?
Quickstart
Installation
Creating a new project
Getting help
Tutorial
Concepts
Deployment
Integrations
Guides
API Reference
About
1.7.2
/ 0.23.2 (libs)
You are viewing an unreleased or outdated version of the documentation
View Latest Documentation
→
Intro to ops and jobs, part one: Write a single-op job
#
You can find the code for this example on
Github
In this guide, we'll touch on Dagster
ops
and
jobs
.
Ops
are individual units of computation that we wire together to form
jobs
.
In this part, you'll:
Write your first op
Write your first job
Execute the job
Step 1: Write your first op
#
Let's write our first Dagster op and save it as
hello.py
.
Typically, you'll define ops by annotating ordinary Python functions with the
@op
decorator.
Our first op finds the sizes of all the files in our current directory and logs them.
import
os
from
dagster
import
job
,
op
,
get_dagster_logger
@op
def
get_file_sizes
(
)
:
files
=
[
f
for
f
in
os
.
listdir
(
"."
)
if
os
.
path
.
isfile
(
f
)
]
for
f
in
files
:
get_dagster_logger
(
)
.
info
(
f"Size of
{
f
}
is
{
os
.
path
.



Documentation Source:
release-1-7-2.dagster.dagster-docs.io/guides/dagster/intro-to-ops-jobs/testable.txt

Documentation Title:
Intro to ops and jobs, part three: Testing ops and jobs | Dagster Docs

Documentation Content:
Intro to ops and jobs, part three: Testing ops and jobs | Dagster Docs
Ask AI
Platform
Dagster+
New
Pricing
Blog
Community
Docs
Sign in
Join us on Slack
Star us
Try Dagster+
Platform
Dagster+
Pricing
Blog
Community
Docs
Contact Sales
Sign in
Try Dagster+
Search
the docs
Press
Ctrl
and
K
to search
Getting started
What's Dagster?
Quickstart
Installation
Creating a new project
Getting help
Tutorial
Concepts
Deployment
Integrations
Guides
API Reference
About
1.7.2
/ 0.23.2 (libs)
You are viewing an unreleased or outdated version of the documentation
View Latest Documentation
→
Intro to ops and jobs, part three: Testing ops and jobs
#
You can find the code for this example on
Github
Data applications are notoriously difficult to test and are therefore often un- or under-tested.
Creating testable and verifiable ops and jobs is one of the focuses of Dagster. We believe ensuring data quality is critical for managing the complexity of data systems.
In the final part of this tutorial, you'll learn how to write unit tests for Dagster jobs and ops.
Testing the job (and its ops)
#
Let's go back to the
diamond
job we wrote in the
prior section
, and ensure that it's working as expected by writing some unit tests.
We'll start by writing a test for the
test_get_total_size
op, which takes a dictionary of file sizes as input and returns the sum of the file sizes. To run an op, we can invoke it directly, as if it's a regular Python function:
def
test_get_total_size
(
)
:
file_sizes
=
{
"file1"
:
400
,
"file2"
:
50
}
result
=
get_total_size
(
file_sizes
)
assert
result
==
450
We'll also write a test for the entire job.



